<?xml version="1.0" encoding="ISO-8859-1" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
	"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
 <title>Homework 3 Test Data</title>
</head>
<body>
<h2>Homework 3 Test Data</h2>
<p>
For linear.cpp, there were 48 test cases, each worth 1 point.  For tree.cpp,
there were 11 cases:  three worth 1 point, seven worth 2 points, and one
worth 5 points.  For maze.cpp, there were 4 test cases, each worth 3
points; and for animal.cpp, there were 6 criteria, each worth 3 points.
</p><p>
The animal.cpp criteria were
</p>
<ol>
<li>
<code>new Animal("Scratchy")</code> must not compile &mdash; Animal must
be abstract.
</li><li>
Animal must not have a default constructor.
</li><li>
Animal must not have a constructor with more than one argument.
</li><li>
Animal must have a virtual destructor.
</li><li>
No class may have a data member whose value is identical for every object
of a particular class type, so for example, Animal must not have a data
member like <code>m_type</code> that would be <code>"cat"</code> for all
Cats, <code>"pig"</code> for all Pigs, etc.; Animal and Duck must not have a
data member like <code>m_moveAction</code> that would be <code>"swim"</code>
for every Duck; and Cat must not have a member like <code>m_sound</code> that
would be <code>"Meow"</code> for every Cat.  Also, objects must not redundantly store data, so you must not have Cat and Animal both storing the name, for
example.
</li><li>
No two function implementations with non-empty bodies may have the same effect.
In particular, this prohibition forbade you from implementing both
<code>Cat::moveAction</code> and <code>Pig::moveAction</code> as
<code>{ return "walk"; }</code>; they should have inherited that
implementation from a common base class (Animal).
</li>
</ol>
<p>
We appended linear.cpp, tree.cpp, and maze.cpp to the end of the following
file to run the tests of those three files; of course, in addition to passing
a test, your function had to have a recursive implementation.
</p>
<pre>
#include &lt;iostream>
#include &lt;string>
#include &lt;algorithm>
#include &lt;cstdlib>
#include &lt;cassert>

using namespace std;

bool anyFalse(const double a[], int n);
int countFalse(const double a[], int n);
int firstFalse(const double a[], int n);
int locateMinimum(const double a[], int n);
bool includes(const double a1[], int n1, const double a2[], int n2);
int countIncludes(const double a1[], int n1, const double a2[], int n2);
void order(double a[], int n);
bool pathExists(string maze[], int nRows, int nCols, int sr, int sc, int er, int ec);

bool somePredicate(double x)
{
	return x &lt; -9;
}

void xxxtestone(int n)
{
	string maze1[10] = {
	  "XXXXXXXXXX",
	  "X.X..X...X",
	  "X.XX.X.XXX",
	  "X....X.X.X",
	  "XX.X.X...X",
	  "XXX..X.X.X",
	  "X...X...XX",
	  "X.XX..X.XX",
	  "X....X...X",
	  "XXXXXXXXXX",
	};
	
	string maze2[10] = {
	  "XXXXXXXXXX",
	  "X.X..X...X",
	  "XXXX.X.XXX",
	  "X....X.X.X",
	  "XX.X.X...X",
	  "XXX..X.X.X",
	  "X...X...XX",
	  "X.XX..X.XX",
	  "X....X...X",
	  "XXXXXXXXXX",
	};
	
	string maze3[10] = {
	  "XXXXXXXXXX",
	  "XX.....XXX",
	  "X..XX....X",
	  "X...X...XX",
	  "X.X.XXX..X",
	  "XXXX..X..X",
	  "XX....X..X",
	  "X.......XX",
	  "X..XXXXXXX",
	  "XXXXXXXXXX",
	};
	
	string maze4[10] = {
	  "XXXXXXXXXX",
	  "XX.....XXX",
	  "X..XX....X",
	  "X...X...XX",
	  "X.X.XXX..X",
	  "XXXX..X..X",
	  "XX....X..X",
	  "X.X.....XX",
	  "X..XXXXXXX",
	  "XXXXXXXXXX",
	};

	double a[10] = { 5, -5, -10, 6, -10, -6, -10, -10, -7, 7 };
	double an[10] = { -10, -15, 10, -16, 10, -16, 10, 10, -17, -17 };
	double x[10] = { 2, 7, 4, 8, -10, 0, -10, -10, 9, 6 };
	double xn[10] = { -2, -7, -4, -8, 10, 0, 10, 10, -9, -6 };
	double y[10] = { 8, 10, 0, 9, 4, 5, -10, 2, 12, 6 };
	double b[4] = { 10, 0, 4, 2 };
	double c[8] = { 1, 9, 7, 3, 9, 7, 5 };
	double d[12] = { 1, 3, 7, 1, 7, 5, 3, 1, 7, 9, 7, 5 };
	double f[16] = { 4, 7, 0, 15, 2, 4, 5, 14, 10, 1, 0, 6, 12, 14, 4, 8 };
	double g[16] = { 15, 14, 14, 12, 10, 8, 7, 6, 5, 4, 4, 4, 2, 1, 0, 0 };

	switch (n)
	{
	    			 default: {
		assert(false);
			} break; case  1: {
		assert(anyFalse(an, 10));
			} break; case  2: {
		assert(anyFalse(an, 8));
			} break; case  3: {
		assert(anyFalse(an+2, 8));
			} break; case  4: {
		assert(!anyFalse(an+8, 2)  &amp;&amp;  anyFalse(an+6, 2));
			} break; case  5: {
		assert(!anyFalse(an, 1));
			} break; case  6: {
		assert(anyFalse(an+2, 1));
			} break; case  7: {
		assert(!anyFalse(an, 0)  &amp;&amp;  !anyFalse(an+2, 0));
			} break; case  8: {
		assert(countFalse(an, 10) == 4);
			} break; case  9: {
		assert(countFalse(an, 8) == 4);
			} break; case 10: {
		assert(countFalse(an+2, 8) == 4);
			} break; case 11: {
		assert(countFalse(an+8, 2) == 0  &amp;&amp;  countFalse(an+6, 2) == 2);
			} break; case 12: {
		assert(countFalse(an, 1) == 0);
			} break; case 13: {
		assert(countFalse(an+2, 1) == 1);
			} break; case 14: {
		assert(countFalse(an, 0) == 0  &amp;&amp;  countFalse(an+2, 0) == 0);
			} break; case 15: {
		assert(firstFalse(an, 10) == 2);
			} break; case 16: {
		assert(firstFalse(an, 8) == 2);
			} break; case 17: {
		assert(firstFalse(an+2, 8) == 0);
			} break; case 18: {
		assert(firstFalse(an+8, 2) == -1  &amp;&amp;  firstFalse(an+6, 2) == 0);
			} break; case 19: {
		assert(firstFalse(an, 1) == -1);
			} break; case 20: {
		assert(firstFalse(an+2, 1) == 0);
			} break; case 21: {
		assert(firstFalse(an, 0) == -1  &amp;&amp;  firstFalse(an+2, 0) == -1);
			} break; case 22: {
		assert(locateMinimum(x, 6) == 4);
			} break; case 23: {
		assert(locateMinimum(x, 5) == 4);
			} break; case 24: {
		assert(locateMinimum(x+7, 3) == 0);
			} break; case 25: {
		assert(locateMinimum(x+8, 2) == 1);
			} break; case 26: {
		assert(locateMinimum(x+2, 2) == 0);
			} break; case 27: {
		assert(locateMinimum(x, 1) == 0);
			} break; case 28: {
		assert(locateMinimum(x+4, 1) == 0);
			} break; case 29: {
		assert(locateMinimum(x, 10) == 4);
			} break; case 30: {
		assert(locateMinimum(x, 0) == -1  &amp;&amp;  locateMinimum(x+2, 0) == -1);
			} break; case 31: {
		assert(includes(y, 10, b, 4));
			} break; case 32: {
		assert(includes(y+1, 9, b, 4));
			} break; case 33: {
		assert(!includes(y+2, 8, b, 4));
			} break; case 34: {
		assert(!includes(y+1, 6, b, 4));
			} break; case 35: {
		assert(includes(y+1, 7, b, 4));
			} break; case 36: {
		assert(includes(y, 10, b+2, 1));
			} break; case 37: {
		assert(includes(y+1, 9, b, 1));
			} break; case 38: {
		assert(!includes(y+2, 8, b, 1));
			} break; case 39: {
		assert(includes(y, 10, b, 0));
			} break; case 40: {
		assert(includes(y, 0, b, 0));
			} break; case 41: {
		assert(includes(y+1, 2, b, 2));
			} break; case 42: {
		assert(!includes(y+2, 2, b+1, 2));
			} break; case 43: {
		assert(!includes(y+2, 2, b+1, 3));
			} break; case 44: {
		assert(!includes(y+1, 1, b, 2));
			} break; case 45: {
		assert(!includes(y+1, 0, b, 1));
			} break; case 46: {
		assert(includes(c, 7, d+3, 3));
			} break; case 47: {
		assert(!includes(c, 7, d+6, 3));
			} break; case 48: {
		assert(includes(c, 7, d+9, 3));
			} break; case 49: {
		assert(countIncludes(c, 0, d, 0) == 1);
			} break; case 50: {
		assert(countIncludes(c, 7, d, 0) == 1);
			} break; case 51: {
		assert(countIncludes(c, 2, d+2, 1) == 0);
			} break; case 52: {
		assert(countIncludes(c, 7, d, 3) == 1);
			} break; case 53: {
		assert(countIncludes(c, 7, d+3, 3) == 2);
			} break; case 54: {
		assert(countIncludes(c, 7, d+6, 3) == 0);
			} break; case 55: {
		assert(countIncludes(c, 7, d+9, 3) == 3);
			} break; case 56: {
		assert(countIncludes(c, 7, d+2, 1) == 2);
			} break; case 57: {
		auto i = f[0];
		order(f, 1);
		assert(f[0] == i);
			} break; case 58: {
		auto i = f[0];
		order(f, 0);
		assert(f[0] == i);
			} break; case 59: {
		order(f, 16);
		assert(equal(f, f+16, g));
			} break; case 60: {
		assert(pathExists(maze1, 10, 10, 8, 6, 1, 1));
			} break; case 61: {
		assert(!pathExists(maze2, 10, 10, 8, 6, 1, 1));
			} break; case 62: {
		assert(pathExists(maze3, 10, 10, 4, 3, 7, 1));
			} break; case 63: {
		assert(!pathExists(maze4, 10, 10, 4, 3, 7, 1));
			}
	}
}

int main()
{
	cout &lt;&lt; "Enter test number: ";
	int n;
	cin >> n;
	testone(n);
	cout &lt;&lt; "Passed" &lt;&lt; endl;
}
</pre>
</body>
</html>
